use mesh_analyzer::{Event, MacAddr};

use std::{
    fs::File,
    io::Read,
    path::{Path, PathBuf}
};

use clap::{App, Arg, Command};
use serde_json::from_slice;

pub fn setup_cli_arg_parser() -> App<'static> {
    Command::new("Mesh Analyzer - Central")
        .author("Carlos Pinto <up201606191@up.pt>")
        .arg(
            Arg::new("FOLDER")
                .required(true)
                .help("Folder with the files generated by all the stations."),
        )
}

pub fn get_files(folder: &Path) -> Vec<PathBuf> {
    let mut files = vec![];
    for entry in folder
        .read_dir()
        .expect("get folder reader")
        .filter(Result::is_ok)
        .map(|e| e.unwrap().path())
    {
        if let Some(ext) = entry.extension() {
            if ext == "json" || ext == "pcap" {
                files.push(entry);
            }
        }
    }

    assert!(
        !files.is_empty(),
        "no '.json' nor '.pcap' files found (extensions must be lowercase)"
    );

    files.sort();
    files
}

#[derive(Debug)]
pub struct Station {
    name: String,
    mac: Vec<MacAddr>,
    events: Vec<Option<Event>>,
    pcap: PathBuf,
}

impl Station {
    pub fn stations_from_files(files: &Vec<PathBuf>) -> Vec<Self> {
        let mut stations = Vec::with_capacity(files.len() / 2);

        // 'get_files()' already makes sure that 'files' is sorted,
        // and also that all elements end with either '.json' or '.pcap'
        // so we can assume that we can do 'f1 == f2' after getting the stems
        // and we can also assume that 'f1' is '.json' and 'f2' is '.pcap' (sort)
        let mut idx = 1;
        while idx < files.len() {
            let f1 = &files[idx - 1].file_stem();
            let f2 = &files[idx].file_stem();
            if f1.is_some() && f1 == f2 {
                let mut events = vec![];
                File::open(&files[idx - 1])
                    .expect("open events file")
                    .read_to_end(&mut events)
                    .expect("read contents of events file");
                let events: Vec<Option<Event>> =
                    from_slice(&events).expect("deserialize events file");
                let mut mac = vec![];
                for event in events
                    .iter()
                    .filter(|e| e.is_some())
                    .map(|e| e.as_ref().unwrap())
                {
                    if !mac.contains(event.mac()) {
                        mac.push(event.mac().clone());
                    }
                }
                stations.push(Self {
                    name: f1.unwrap().to_string_lossy().to_string(),
                    mac,
                    events,
                    pcap: files[idx].clone(),
                });
                idx += 1;
                if idx < files.len() {
                    let next = &files[idx].file_stem();
                    if idx == files.len() - 1 && next.is_some() {
                        eprintln!("{} is missing a file", next.unwrap().to_string_lossy());
                    }
                }
            } else if f1.is_some() {
                eprintln!("{} is missing a file", f1.unwrap().to_string_lossy());
                if idx == files.len() - 1 && f2.is_some() {
                    eprintln!("{} is missing a file", f2.unwrap().to_string_lossy());
                }
            }
            idx += 1;
        }

        assert!(!stations.is_empty(), "no stations found");

        Self::sort(&mut stations);
        stations
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn mac(&self) -> &[MacAddr] {
        &self.mac
    }

    pub fn events(&self) -> &[Option<Event>] {
        self.events.as_slice()
    }

    pub fn pcap(&self) -> &Path {
        &self.pcap
    }

    fn sort(stations: &mut [Self]) {
        let mut events = vec![];
        for station in stations.iter_mut() {
            station
                .events
                .iter()
                .for_each(|event| events.push((station.name.clone(), event.clone().unwrap())));
            station.events.clear();
        }

        events.sort_by(|a, b| {
            a.1.ts()
                .partial_cmp(b.1.ts())
                .expect("sort events by timestamp")
        });

        for event in &events {
            for station in stations.iter_mut() {
                if event.0 == station.name {
                    station.events.push(Some(event.1.clone()));
                } else {
                    station.events.push(None);
                }
            }
        }
    }
}
